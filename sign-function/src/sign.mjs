import { Hash } from '@aws-sdk/hash-node';
import { HttpRequest } from '@aws-sdk/protocol-http';
import { SignatureV4 } from '@aws-sdk/signature-v4';
import { URL } from 'url';

export const sign = async (region, credentials, authMethod, url, query = {}, headers = {}) => {
  const urlObject = new URL(url);

  // Add query parameters passed through the argument, if any.
  if (Object.keys(query).length > 0) {
    Object.keys(query).forEach((param) => {
      urlObject.searchParams.set(param, query[param]);
    });
  }

  const httpRequest = new HttpRequest({
    headers: {
      ...headers,
      host: urlObject.hostname,
    },
    hostname: urlObject.hostname,
    path: urlObject.pathname,
    protocol: urlObject.protocol,
    query: Object.fromEntries(urlObject.searchParams),
  });

  const signatureV4 = new SignatureV4({
    credentials,
    region,
    service: 'execute-api',
    sha256: Hash.bind(null, 'sha256'),
  });

  let signedHttpRequest;
  if (authMethod === 'header') {
    signedHttpRequest = await signatureV4.sign(httpRequest);
  } else if (authMethod === 'query') {
    signedHttpRequest = await signatureV4.presign(httpRequest);

    // Add query parameters generated by presigning.
    Object.keys(signedHttpRequest.query).forEach((param) => {
      urlObject.searchParams.set(param, signedHttpRequest.query[param]);
    });
  } else {
    throw new Error(`Unknown authentication method "${authMethod}"!`);
  }

  return {
    headers: signedHttpRequest.headers,
    url: urlObject.toString(),
  };
};
